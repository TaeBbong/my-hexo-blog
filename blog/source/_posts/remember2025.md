---
title: "[회고록] 2025년"
excerpt: "더 좋은 사람 되기"
thumbnail: img/images/placeholder-big-1.jpg 
date: 2025-12-31 23:56:02
tags:
category:
  - 생활
  - 회고
toc: true
widgets:
  - type: toc
    position: left
  - type: category
    position: left
sidebar:
  left:
    sticky: true
head:
    canonical_url: https://taebbong.github.io
    open_graph:
        image: img/images/placeholder-big-1.jpg
---

2025년은 유난히 더 빨리 지나간 것 같습니다. 나이가 들수록 시간이 빨리 흐른다고는 하지만, 1년 단위로 체감될 일인가 싶네요. 사실 저는 시간이 빨리 간 이유에 대해 알고 있습니다. 보통 바쁘게, 열심히 살면 하루하루 금방 지나갑니다. 1년이 지난 12월의 마지막 날, 글을 쓰며 어쩐일로 씁쓸함이나 아쉬움이 남지 않는걸로 보아 나름 잘 살았던 모양입니다.

## 무엇을 어떻게 공부했는가 - Flutter 편

올해도 어김없이 플러터와 가장 많은 시간을 함께 했습니다. 어쩜 하면 할 수록 새로운 것들만 알게 되는 것이, 기술 하나를 깊이 있게 알아 간다는 게 참 어려운 일이라는 걸 새삼 느낍니다.

작년 회고에서 세웠던 목표는 잘 만들어진 오픈소스 프로젝트들을 분석하고 거기서부터 공부를 시작하자는 것이었습니다. 깊이를 원할 때 가장 큰 벽은 실무 레벨에서 어떤 식으로 개발하는지 모른다는 것입니다. 그나마 이를 가장 근접하게 만날 수 있는 것이 오픈소스 프로젝트들이라고 생각했고, 한 3개 정도 보면 공통된 지점을 발견할 수 있겠다 생각했어요.

가장 큰 도움이 되었던 프로젝트는 `flutter_pokedex`였습니다. 여기서는 `injectable`, `get_it`, `freezed`, `bloc` 등 이른바 모던 스택을 사용하고 있었습니다. `bloc` 대신 `riverpod` 정도만 넣으면 플러터에서는 가장 스탠다드한 방식인 것 같아요. 부끄럽게도, 그 전까진 제대로 사용해본 적 없는 스택이었습니다. 그래서 이 기술들을 조금씩 알아보고 익히다가, 실습할 수 있는 프로젝트를 시작하기로 결심했습니다. 그것이 **청모(ChungMo)** 프로젝트였습니다.

[청모 프로젝트 개발기는 여기서 보실 수 있습니다.](https://velog.io/@taebbong/AI%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%B2%AD%EC%B2%A9%EC%9E%A5-%EC%95%B1-%EC%B2%AD%EB%AA%A8-%EA%B0%9C%EB%B0%9C-%EB%AA%A8%ED%97%98%EA%B8%B0)

프로젝트를 하면서 모던 스택에 대한 경험은 쌓아볼 수 있었어요. 그러면서도 마음 속에 남아 있던 불안감이 있었습니다. 

> 나는 왜 플러터를 공부하고 있었지? 하나를 정말 깊이 있게 파면 어떤 포지션으로도 내 능력을 어필 할 수 있겠지. 운이 좋다면 구글 플러터 팀에도 들어갈 수 있을거야. 근데 그럼 그냥 앱 좀 만들 줄 안다고 깊이가 쌓였다고 할 수 있나? 그 전에, 플러터에 대해서는 잘 알고 있나? 난 정말 플러터의 구조와 동작 원리, 설계 컨셉을 잘 이해하고 쌓는 중일까?

플러터 팀에 합류하는 것을 목표로 하든, 플러터를 사용하는 어떤 회사를 목표로 하든, 제2의 스택을 사용하는 회사에 내 깊이감을 보여주든 그저 플러터로 프로젝트 몇 개 하는 것은 내가 추구하는 깊이의 차별화가 아니라고 생각했습니다. 그래서 좀 더 코어한 개념 공부가 필요하다고 느꼈고, 시작했습니다. 마침 이때 `Flutter Engineering` 책을 리뷰할 기회가 생겨 읽으며 내가 모르는 개념에 무엇이 있나 체크해봤습니다. 그리고 그것들을 하나씩 정리하기 시작했어요. 이맘쯤 **옵시디언**을 제대로 활용하기 시작하며 TIL을 정리했습니다. `const`는 어떻게 `canonical` 객체로 관리되는가, 